<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>AIMIXSAKA</title><link>/</link><description>AIMIXSAKA</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>aimixsaka@gmail.com (aimixsaka)</managingEditor><webMaster>aimixsaka@gmail.com (aimixsaka)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 14 Nov 2023 12:51:42 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>/nix-pills-note-9/</link><pubDate>Tue, 14 Nov 2023 12:51:42 +0800</pubDate><author><name>aimixsaka</name></author><guid>/nix-pills-note-9/</guid><description>1 第9篇 2 callPackage pattern 在前面的一节中，我们为了用户灵活度和与仓库文件解耦合，用了input design(将包构建写作函数) 并为了方便包的调用，集中管</description></item><item><title/><link>/hello/</link><pubDate>Tue, 14 Nov 2023 12:51:41 +0800</pubDate><author><name>aimixsaka</name></author><guid>/hello/</guid><description>Hello World ?</description></item><item><title/><link>/nix-pills-note-1/</link><pubDate>Tue, 14 Nov 2023 12:51:41 +0800</pubDate><author><name>aimixsaka</name></author><guid>/nix-pills-note-1/</guid><description>1 第1篇 2 可变和不可变之间的优缺 用hash能很方便同一软件多版本的共存。传统FHS无法很自然地做到这点 更新库时，由于nix硬编码了依赖路径，</description></item><item><title/><link>/nix-pills-note-10/</link><pubDate>Tue, 14 Nov 2023 12:51:41 +0800</pubDate><author><name>aimixsaka</name></author><guid>/nix-pills-note-10/</guid><description>1 第10篇 2 override pattern 前面我们利用函数参数，通过改变调用时传入的参数，来获取一个包的不同变种 但是那仍然有些坏处，比如需要包的维护者手动调用来传参，</description></item><item><title/><link>/nix-pills-note-11/</link><pubDate>Tue, 14 Nov 2023 12:51:41 +0800</pubDate><author><name>aimixsaka</name></author><guid>/nix-pills-note-11/</guid><description>1 第11篇 2 overriding packages咕咕咕&amp;hellip;</description></item><item><title/><link>/nix-pills-note-12/</link><pubDate>Tue, 14 Nov 2023 12:51:41 +0800</pubDate><author><name>aimixsaka</name></author><guid>/nix-pills-note-12/</guid><description><![CDATA[1 第12篇 2 nix store paths 来看一下Nix的hash部分如何求值 先以单个文件为例 $ echo mycontent &gt; myfile 1 2 nix-repl&gt; derivation { system = &#34;x86_64-linux&#34;; builder = ./myfile; name = &#34;foo&#34;; } «derivation /nix]]></description></item><item><title/><link>/nix-pills-note-13/</link><pubDate>Tue, 14 Nov 2023 12:51:41 +0800</pubDate><author><name>aimixsaka</name></author><guid>/nix-pills-note-13/</guid><description>1 第13篇 2 stdenv stdenv 是我们打包中最常用到的工具，nixpgks中绝大多数包都是用stdenv.mkDerivation打的 stdenv 只是一个普通的der</description></item><item><title/><link>/nix-pills-note-2/</link><pubDate>Tue, 14 Nov 2023 12:51:41 +0800</pubDate><author><name>aimixsaka</name></author><guid>/nix-pills-note-2/</guid><description>1 第2篇 2 derivation 用builtins.derivation来创建derivation 以Nix language的角度来看，一个derivation只</description></item><item><title/><link>/nix-pills-note-3/</link><pubDate>Tue, 14 Nov 2023 12:51:41 +0800</pubDate><author><name>aimixsaka</name></author><guid>/nix-pills-note-3/</guid><description>1 第3篇 2 working derivation 为了让derivation两个阶段成功运行，除了必要的三个元素，还需要out path存在 为了构建out path，使用bash脚</description></item><item><title/><link>/nix-pills-note-4/</link><pubDate>Tue, 14 Nov 2023 12:51:41 +0800</pubDate><author><name>aimixsaka</name></author><guid>/nix-pills-note-4/</guid><description>1 generic builder 2 第4篇 前面我们构建了两个简单的derivation。每个derivation含有两个部分： 描述构建过程，作为builder的参数的b</description></item></channel></rss>