[{"categories":null,"content":" 1 第9篇","date":"2023-11-14","objectID":"/nix-pills-note-9/:1:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-9/#第9篇"},{"categories":null,"content":" 2 callPackage pattern 在前面的一节中，我们为了用户灵活度和与仓库文件解耦合，用了input design(将包构建写作函数) 并为了方便包的调用，集中管理，我们把包都集中在default.nix 但是还是有一点不好的地方，在defaut.nix中我们还是需要手动传参给函数，所以参数在graphviz.nix和default.nix中重复了两次 我们可以写一个函数(callPackage)来自动地填充参数，再和自定义的参数set做个并集 它应该这么用 { lib1 = callPackage package1.nix { }; program2 = callPackage package2.nix { someoverride = overriddenDerivation; }; } 所以callPackage应该是一个接受一个参数并返回一个函数的函数(或者说接收两个参数) 在写callPackage的实现前我们先看看Nix中内置的几个有用的函数 builtins.functionArgs {fun} 返回函数的参数集合，元素是argname = true|false的形式，有默认参数值的为true，否则为false。而我们只关心参数的名字 builtins.intersectAttrs {attr set1} {attr set2} 对两个集合做交集，如果key重复，用后一个覆盖 那么callPackage可以有如下实现 callPackage = path: overrides: let f = import path; in f ((builtins.intersectAttrs (builtins.functionArgs f) allPkgs) // overrides); 具体default.nix中callPackage可以这么实现 default.nix let nixpkgs = import \u003cnixpkgs\u003e { }; # pkgs defined bellow allPkgs = nixpkgs // pkgs; callPackage = path: overrides: let f = import path; in f ((builtins.intersectAttrs (builtins.functionArgs f) allPkgs) // overrides); pkgs = with nixpkgs; { mkDerivation = import ./autotoolsv2.nix nixpkgs; graphviz = callPackage ./graphviz.nix { }; hello = callPackage ./hellov4.nix { }; }; in pkgs 唔，简洁，精简的代码… ！？等会儿，callPackage用了allPkgs，但是allPkgs需要pkgs，而pkgs里又调用了callPackage，这难道不会死循环吗？ 哈哈，这是函数式惰性求值的魔法了。builtins.intersectAttrs 不需要知道 allPkgs的全部键值对，只有当前一个参数中有nixpkgs中不含有的包时才会对allPkgs 剩余部分逐个求值，有则返回 ","date":"2023-11-14","objectID":"/nix-pills-note-9/:2:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-9/#callpackage-pattern"},{"categories":null,"content":"Hello World ? ","date":"2023-11-14","objectID":"/hello/:0:0","series":null,"tags":null,"title":"","uri":"/hello/#"},{"categories":null,"content":" 1 第1篇","date":"2023-11-14","objectID":"/nix-pills-note-1/:1:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-1/#第1篇"},{"categories":null,"content":" 2 可变和不可变之间的优缺 用hash能很方便同一软件多版本的共存。传统FHS无法很自然地做到这点 更新库时，由于nix硬编码了依赖路径，所有依赖于这个库的软件都需要重新编译 而FHS大多时候只是原地替换，无需重新编译 不把文件存在全局使得运行时动态组合变得困难。例如firefox插件， 由于nix不假设全局的状况，firefox并不知道插件的路径。需要通过wrap firefox的方法。 每次“更新”，只是在更换指向的目录。原有的软件将会保留直到手动gc ","date":"2023-11-14","objectID":"/nix-pills-note-1/:2:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-1/#可变和不可变之间的优缺"},{"categories":null,"content":" 1 第10篇","date":"2023-11-14","objectID":"/nix-pills-note-10/:1:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-10/#第10篇"},{"categories":null,"content":" 2 override pattern 前面我们利用函数参数，通过改变调用时传入的参数，来获取一个包的不同变种 但是那仍然有些坏处，比如需要包的维护者手动调用来传参，如果包的可选项多了起来，一个包的不同变种就有十几种，每个特性都让维护者来调用形成一个新derivation 不太现实。 相反，如果能让用户拥有改变参数的能力，那么他可以很自然地根据自己的需求来传参获取derivation，而包维护者只需要为那些选项设一个默认值即可 比如 与其： graphviz = callPackage ./graphviz.nix { }; graphviz = callPackage ./graphviz { gdSupport = false; }; 不如： graphvizCore = pkgs.graphviz.override { gdSupport = false; }; 函数式让我们很容易能够做到这一点，这是其它只用一系列用串行shell函数描述打包的包管理比较难做到的 基本的思路是为每个derivation的返回值(一个attr set)添加一个override的key，它的value是一个函数，该函数接收一个set类型的参数，返回一个新的derivation 而derivation最后都是调用打包函数(graphviz.nix等)形成的，那么这个override应该应该是 用已有的参数，和提供的参数(override的参数)，做个 //，然后把这个合集传给打包函数，得到一个新的derivation。 另，还需要返回的derivation仍然具有override的能力(属性) 那么可以写出类似如下的函数 { makeOverridable = f: origArgs: let origRes = f origArgs; in origRes // { override = newArgs: f (origArgs // newArgs); }; } 其中origRes是一个derivation，origRes // { override = newArgs: f (origArgs // newArgs); } 也是一个derivation 为了让返回的derivation也具有override的能力，可以这么改： # 为了让makeOverridable能访问自身，rec是必需的 rec { makeOverridable = f: origArgs: let origRes = f origArgs; in origRes // { override = newArgs: makeOverridable f (origArgs // newArgs); }; } 唔，精巧！ 最后只需要让我们的callPackage集成这个功能就大功告成了 default.nix let nixpkgs = import \u003cnixpkgs\u003e { }; # pkgs defined bellow allPkgs = nixpkgs // pkgs; makeOverridable = f: origArgs: let origRes = f origArgs; in origRes // { override = newArgs: makeOverridable f (origArgs // newArgs); }; callPackage = path: overrides: let f = import path; in makeOverridable f ((builtins.intersectAttrs (builtins.functionArgs f) allPkgs) // overrides); pkgs = with nixpkgs; { mkDerivation = import ./autotoolsv2.nix nixpkgs; graphviz = callPackage ./graphviz.nix { }; graphvizCore = callPackage ./graphviz.nix { gdSupport = false; }; hello = callPackage ./hellov4.nix { }; }; in pkgs ","date":"2023-11-14","objectID":"/nix-pills-note-10/:2:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-10/#override-pattern"},{"categories":null,"content":" 1 第11篇","date":"2023-11-14","objectID":"/nix-pills-note-11/:1:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-11/#第11篇"},{"categories":null,"content":" 2 overriding packages咕咕咕… ","date":"2023-11-14","objectID":"/nix-pills-note-11/:2:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-11/#overriding-packages"},{"categories":null,"content":" 1 第12篇","date":"2023-11-14","objectID":"/nix-pills-note-12/:1:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-12/#第12篇"},{"categories":null,"content":" 2 nix store paths 来看一下Nix的hash部分如何求值 先以单个文件为例 $ echo mycontent \u003e myfile nix-repl\u003e derivation { system = \"x86_64-linux\"; builder = ./myfile; name = \"foo\"; } «derivation /nix/store/y4h73bmrc9ii5bxg6i7ck6hsf5gqv8ck-foo.drv» $ nix derivation show /nix/store/y4h73bmrc9ii5bxg6i7ck6hsf5gqv8ck-foo.drv { \"/nix/store/y4h73bmrc9ii5bxg6i7ck6hsf5gqv8ck-foo.drv\": { \"args\": [], \"builder\": \"/nix/store/xv2iccirbrvklck36f1g7vldn5v58vck-myfile\", \"env\": { \"builder\": \"/nix/store/xv2iccirbrvklck36f1g7vldn5v58vck-myfile\", \"name\": \"foo\", \"out\": \"/nix/store/hs0yi5n5nw6micqhy8l1igkbhqdkzqa1-foo\", \"system\": \"x86_64-linux\" }, \"inputDrvs\": {}, \"inputSrcs\": [ \"/nix/store/xv2iccirbrvklck36f1g7vldn5v58vck-myfile\" ], \"name\": \"foo\", \"outputs\": { \"out\": { \"path\": \"/nix/store/hs0yi5n5nw6micqhy8l1igkbhqdkzqa1-foo\" } }, \"system\": \"x86_64-linux\" } } (也可以用nix-store --add myfile来得到这个hash) inputDrvs部分文件的hash部分的求值 其中/nix/store/xv2iccirbrvklck36f1g7vldn5v58vck-myfile的hash部分是怎么求出的呢？ 计算出文件的hash $ nix-hash --type sha256 myfile 2bfef67de873c54551d884fdab3055d84d573e654efa79db3c0d7b98883f9ee3 ( 注：nix-hash做的事比普通的sha256sum要多一步，就是先把文件或目录打成NAR格式，以上面为例，其等于nix-store --dump | sha256sum 而nix-hash --type sha256 --flat myfile和sha256sum myfile是等价的 对于Nix来说，只有两种内容格式，flat for regular files, or recursive for NAR serializations which can be anything. ) 创建字符描述 $ echo -n \"source:sha256:2bfef67de873c54551d884fdab3055d84d573e654efa79db3c0d7b98883f9ee3:/nix/store:myfile\" \u003e myfile.str 计算出最后的hash $ nix-hash --type sha256 --truncate --base32 --flat myfile.str xv2iccirbrvklck36f1g7vldn5v58vck out pathhash部分的求值 之前我们说过，out path在derivation实际被构建之间就已知了，而且只与输入有关 out path的hash求值与输入类似，除了类型变为了output:out(多个输出则类型分别为output:\u003cid\u003e) 获取.drv文件中除了out path部分的内容的hash cp -f /nix/store/y4h73bmrc9ii5bxg6i7ck6hsf5gqv8ck-foo.drv myout.drv sed -i 's,/nix/store/hs0yi5n5nw6micqhy8l1igkbhqdkzqa1-foo,,g' myout.drv ( 这么做有点hack，实际上out path的求值过程中应该是有个中间文件，其内容类似如下(全在一行，没有换行): Derive([(\"out\",\"\",\"\",\"\")],[],[\"/nix/store/xv2iccirbrvklck36f1g7vldn5v58vck-myfile\"],\"x86_64-linux\",\"/nix/store/xv2iccirbrvklck36f1g7vldn5v58vck-myfile\",[],[(\"builder\",\"/nix/store/xv2iccirbrvklck36f1g7vldn5v58vck-myfile\"),(\"name\",\"foo\"),(\"out\",\"\"),(\"system\",\"x86_64-linux\")]) 即out内容为空的.drv文件的内容 ) 求hash $ sha256sum myout.drv 1bdc41b9649a0d59f270a92d69ce6b5af0bc82b46cb9d9441ebc6620665f40b5 myout.drv 创建字符串描述 $ echo -n \"output:out:sha256:1bdc41b9649a0d59f270a92d69ce6b5af0bc82b46cb9d9441ebc6620665f40b5:/nix/store:foo\" \u003e myout.str 对字符串描述文件求hash，得到最后的hash $ nix-hash --type sha256 --truncate --base32 --flat myout.str hs0yi5n5nw6micqhy8l1igkbhqdkzqa1 tar包采用一种特别的求值方式，其只与文件的内容有关，而与文件名无关(fixed-output paths)，但步骤类似 derivation有三个特别的和hash相关的参数: outputHashMode outputHash outputHashAlgo，分别表示该derivation的hash的模式(“flat” or “recursive”)，hash值和hash的算法 (refer: outputHashMode) 当指定了outputHash时，derivation函数会确保该derivation的out path的hash部分的值为outputHash的值 以之前的tar文件hello-2.12.1.tar.gz为例 $ sha256sum hello-2.12.1.tar.gz的到hash8d99142afd92576f30b0cd7cb42a8dc6809998bc5d607d88761f512e26c7db20 $ nix-instantiate --expr 'derivation { system = \"x86_64-linux\"; name = \"helloTar\"; builder = \"none\"; outputHash = \"8d99142afd92576f30b0cd7cb42a8dc6809998bc5d607d88761f512e26c7db20\"; outputHashMode = \"flat\"; outputHashAlgo = \"sha256\"; }'得到derivation /nix/store/gszqyzlnns85sjy1rj9jg04kil5fl39w-helloTar.drv 通过nix derivation show /nix/store/gszqyzlnns85sjy1rj9jg04kil5fl39w-helloTar.drv 查看derivation的详细信息 { \"/nix/store/gszqyzlnns85sjy1rj9jg04kil5fl39w-helloTar.drv\": { \"args\": [], \"builder\": \"none\", \"env\": { \"builder\": \"none\", \"name\": \"helloTar\", \"out\": \"/nix/store/qwj2km5i1p31616kmxgkm9iinfxs7iqr-helloTar\", \"outputHash\": \"8d99142afd92576f30b0cd7cb42a8dc6809998bc5d607d88761f512e26c7db20\", \"outputHashAlgo\": \"sha256\", \"outputHashMode\": \"flat\", \"system\": \"x86_64-linux\" }, \"inputDrvs\": {}, \"inputSrcs\": [], \"name\": \"helloTar\", \"outputs\": { \"out\": { \"hash\": \"8d99142afd92576f30b0cd7cb42a8dc6809998bc5d607d88761f512e26c7db20\", \"hashAlgo\": \"sha256\", \"path\": \"/nix/store/qwj2km5i1p31616kmxgkm9iinfxs7iqr-helloTar\" } }, \"system\": \"x","date":"2023-11-14","objectID":"/nix-pills-note-12/:2:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-12/#nix-store-paths"},{"categories":null,"content":" 1 第13篇","date":"2023-11-14","objectID":"/nix-pills-note-13/:1:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-13/#第13篇"},{"categories":null,"content":" 2 stdenv stdenv 是我们打包中最常用到的工具，nixpgks中绝大多数包都是用stdenv.mkDerivation打的 stdenv 只是一个普通的derivation，其为stdenv.mkDerivation提供out path。可以用nix build 'nixpgks#stdenv'来看看其构建的东西 $ ls -R result result: nix-support setup result/nix-support: 重要的是setup文件，打开看看的话可以发现和我们之间写的setup.sh很类似 可以通过nix derivation show 'nixpgks#stdenv'看看它的.drv的详细信息( 能看到args也是有个builder.sh 还有defaultBuildInputs initialPath等，类似我们之前写过的baseInputs，包含(提供)了许多基本工具(gcc, gawk…) ) stdenv.mkDerivation更类似我们写过的autotoolsv2.nix，它是一个函数， 接收一个set，返回一个derivation。其args用了stdenv这个derivation的out path { ... builder = attrs.realBuilder or shell; # default-builder类似我们写的generic-builder.sh。其只是source $stdenv/setup，然后调用generibBuild args = attrs.args or [\"-e\" (attrs.builder or ./default-builder.sh)]; # 这里result就是stdenv derivation。在nix-build或nix-shell时会转为out path并作为环境变量 # 所以`nix-shell -E 'with import \u003cnixpkgs\u003e {}; stdenv.mkDerivation { name = \"foo\"; }'`后`echo $stdenv`能看见stdenv的out path stdenv = result; ... } ","date":"2023-11-14","objectID":"/nix-pills-note-13/:2:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-13/#stdenv"},{"categories":null,"content":" 1 第2篇","date":"2023-11-14","objectID":"/nix-pills-note-2/:1:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-2/#第2篇"},{"categories":null,"content":" 2 derivation 用builtins.derivation来创建derivation 以Nix language的角度来看，一个derivation只是一个含有type = derivation 的 attribute set derivation有必要的三个元素: name system builder 对 derivation { name = \"foo\"; system = \"fake-system\"; builder = \"fake-builder\"; } 进行求值，会创建一个/nix/store/???.drv文件，但不会直接进行构建 .drv文件描述了如何构建一个derivation(attribute set) build .drv文件产生output(可能有多个输出) .drv 和 out paths都在/nix/store/中 可以通过nix derivation show /nix/store/hash-name.drv来以json的形式查看该.drv所表示的详细信息 在真正构建之前out path就已经确定了(所以后面写构建脚本时可以直接用$out，其正是已经求值出的out path路径(/nix/store/hash-name)。 只不过该路径(文件或者目录)还不存在，需要在脚本中自己创建) derivation的out path 只由当前版本下的Nix的inputs决定，所以在构建之前就已知了，并不是由构建的结果(即out)的内容来决定的 但是也有根据内容决定的out path(例如tarball的out path) ([content-addressable](https://en.wikipedia.org/wiki/Content-addressable_storage)) attribute set 中的outPath类似java中的toString，当求值builtins.toString { foo = ???; outPath = \"some\"; }时，结果是\"some\" 总的来说，有两个阶段 (eval/instantiate) stage 对derivation {...}进行求值，得到.drv文件，并获得其返回值。.drv文件的中的依赖(inputDrvs)是递归求值的 (realize/build) stage 对.drv进行构建，创建out path，也是递归地进行构建的(先构建出inputDrvs中的out out) ","date":"2023-11-14","objectID":"/nix-pills-note-2/:2:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-2/#derivation"},{"categories":null,"content":" 1 第3篇","date":"2023-11-14","objectID":"/nix-pills-note-3/:1:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-3/#第3篇"},{"categories":null,"content":" 2 working derivation 为了让derivation两个阶段成功运行，除了必要的三个元素，还需要out path存在 为了构建out path，使用bash脚本来进行构建，通过向derivation函数传递参数args = [ ./builder.sh ]来让builder(bash)运行builder.sh构建脚本 第一个可运行的derivation builder.sh declare -xp echo foo \u003e $out nix repl -f '\u003cnixpkgs\u003e' nix-repl\u003e d = derivation { name = \"foo\"; builder = \"${bash}/bin/bash\"; args = [ ./builder.sh ]; system = builtins.currentSystem; } nix-repl\u003e :b d 通过nix log /nix/store/gvwysj9dkjjan9hvxfnwq2f97chnz437-foo.drv来查看构建过程中的日志(包含打印出的环境变量) 使用nix derivation show /nix/store/gvwysj9dkjjan9hvxfnwq2f97chnz437-foo.drv查看out path等 第二个derivation 由前一个derivation的日志可知，PATH=\"/path-not-set\"，所以为了构建一个简单的c程序，我们需要将gcc的bin路径加入PATH中 对derivation函数来说，所有传给它的键值对(除了部分保留的元素，如args)都会以一定的规则转换成builder的环境变量 如derivation { other = ./other.file; some = \"some\"; }，其中other(转换成复制到/nix/store/中的地址)和some会以环境变量的形式传给builder(多为bash) ","date":"2023-11-14","objectID":"/nix-pills-note-3/:2:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-3/#working-derivation"},{"categories":null,"content":" 源码，作为src环境变量传入simple.c void main() { puts(\"Simple!\"); } ","date":"2023-11-14","objectID":"/nix-pills-note-3/:0:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-3/#源码作为src环境变量传入"},{"categories":null,"content":" 作为args参数传入，是builder(bash)的参数 (bash simple-builder.sh)simple-builder.sh export PATH=\"$coreutils/bin/:$gcc/bin\" mkdir $out gcc -o $out/simple $src ","date":"2023-11-14","objectID":"/nix-pills-note-3/:0:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-3/#作为args参数传入是builderbash的参数-bash-simple-buildersh"},{"categories":null,"content":" 调用derivation求值， 并构建 nix-repl\u003e d = derivation { name = \"simple\"; builder = \"{bash}/bin/bash\"; system = builtins.currentSystem; args = [ ./builder.sh ]; src = ./simple.c; inhert (pkgs) gcc coreutils; } nix-repl\u003e :b d 运行 /nix/store/5hykxkxc8rj9c0q5p19fmagk5ms2rczx-simple/simple 用.nix文件而不是nix repl确保reproducible simple.nix let pkgs = import \u003cnixpkgs\u003e { }; in derivation { name = \"simple\"; builder = \"${pkgs.bash}/bin/bash\"; system = builtins.currentSystem; args = [ ./simple-builder.sh ]; inherit (pkgs) gcc coreutils; src = ./simple.c; } 使用nix build --file ./simple.nix 或者 nix-build ./simple.nix来求值并构建该derivation (注：nix-build实际上做了两件事， nix-instantiate和nix-sotre -r) ","date":"2023-11-14","objectID":"/nix-pills-note-3/:0:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-3/#调用derivation求值-并构建"},{"categories":null,"content":" 1 generic builder","date":"2023-11-14","objectID":"/nix-pills-note-4/:1:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-4/#generic-builder"},{"categories":null,"content":" 2 第4篇 前面我们构建了两个简单的derivation。每个derivation含有两个部分： 描述构建过程，作为builder的参数的builder.sh和simple-builder.sh部分 调用构建脚本，真正进行求值和构建部分的simple.nix 这么做的坏处很明显，每打一个包就要写一个构建脚本(simple-builder.sh这种)，而且每个 builder脚本都会被复制到/nix/store里，容易把/nix/store搞乱 解决方案是写一个相对更通用的generic-builder.sh，把变化的量(如包名，依赖等)都写在packname.nix里，通过环境变量传过去 而在generic-builder.sh中，读取变量，并利用bash的灵活性进行构建 通用性构建的一个例子是使用autotools的项目的构建 generic-builder.sh set -e unset PATH for p in $buildInputs; do export PATH=$p/bin${PATH:+:}$PATH done tar -xf $src for d in *; do if [ -d \"$d\" ]; then cd \"$d\" break fi done ./configure --prefix=$out make make install 用GNU hello world来测试这个generic-builder.sh 源码： https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz hello.nix let pkgs = import \u003cnixpkgs\u003e { }; in derivation { name = \"hello\"; builder = \"${bash}/bin/bash\"; system = builtins.currentSystem; args = [ ./generic-builder.sh ]; src = ./hello-2.12.1.tar.gz; buildInputs = with pkgs; [ gnutar gzip gnumake gcc coreutils gawk gnused gnugrep binutils.bintools ]; } 这里的buildInputs提供了一些打包过程中常用的工具(不一定全会用到) (注：对于传进去的list型参数，转换为环境变量时会先将每个元素用对应的规则转换为string，然后用空格连接(方便bash做for循环)) 虽然构建脚本是统一了，但是每次写一个新包，packname.nix中仍有不少重复，可以把这部分抽出来，把derivation包装一下 autotools.nix pkgs: attrs: let defaultAttrs = { builder = \"${pkgs.bash}/bin/bash\"; args = [ ./generic-builder.sh ]; baseInputs = with pkgs; [ gnutar gzip gnumake gcc coreutils gawk gnused gnugrep binutils.bintools ]; buildInputs = [ ]; system = builtins.currentSystem; }; in derivation (defaultAttrs // attrs) baseInputs作为共用的基础性的构建工具 buildInputs是用户自己添加的构建依赖 由于这里我们引入了一个baseInputs，需要在generic-builder.sh的for循环中把它加入PATH 做好autotools.nix的抽象后，可以试着用它来构建一个包了 hellov2.nix let pkgs = import \u003cnixpkgs\u003e { }; mkDerivation = import ./autotools.nix pkgs; in mkDerivation { name = \"hello\"; src = ./hello-2.12.1.tar.gz; } 这样简单多了！每个包的.nix文件无需再重复写共用的依赖 ","date":"2023-11-14","objectID":"/nix-pills-note-4/:2:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-4/#第4篇"},{"categories":null,"content":" 1 第5篇","date":"2023-11-14","objectID":"/nix-pills-note-5/:1:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-5/#第5篇"},{"categories":null,"content":" 2 automatic runtime 分析构建时依赖和运行时依赖 build dependency nix-instantiate hellov2.nix /nix/store/3g7ccvlxrpmb2s9m4vkasz8y6444fwsc-hello.drv nix-store -q --references /nix/store/3g7ccvlxrpmb2s9m4vkasz8y6444fwsc-hello.drv /nix/store/3077wznnjrbd318k17j7fjsgxy9xgrcl-gnutar-1.35.drv /nix/store/3mdqlcjhflm8mdm2192bap27g8zv60sq-generic-builder.sh /nix/store/982f8csn028v499k0fkrl66x28cbj3b8-bash-5.2-p15.drv /nix/store/dxsdysn7gpyjajiqjvab03bilarjjn15-coreutils-9.3.drv /nix/store/f7glbcn7n59k22b911bx1vyy13g4bdxh-binutils-2.40.drv /nix/store/fimilhby9fyqbfwmw826id3hwfhya6qx-hello-2.12.1.tar.gz /nix/store/fis965lcaxlhxsibjqr7g99l074niraj-gnumake-4.4.1.drv /nix/store/jhkn3namnqqkl7hmxmcml0ffir0dv774-gnugrep-3.11.drv /nix/store/n20wzc7mdmdq91vq5b6gklsz1171k82r-gnused-4.9.drv /nix/store/w1nk39ahhnzkj9yqa5vpggxgff11056g-gawk-5.2.2.drv /nix/store/w3f8imf2csiwc7jfinmgf682rvhg7fna-gcc-wrapper-12.3.0.drv /nix/store/zq7wlgpchcp0857swj8jv5hdwk0pzlg7-gzip-1.12.drv runtime dependency derivation的运行时依赖是由Nix自动识别的 把derivation的out path序列化为NAR 对derivation的每个构建时依赖及其对应的out path，在NAR中寻找该out path的hash部分 如果找到了，说明这个out path是该derivation的运行时依赖 通过nix-store -r /nix/store/3g7ccvlxrpmb2s9m4vkasz8y6444fwsc-hello.drv 得到out path /nix/store/x3skf9wy7hpigvp8dca7kg1xafwhy5gv-hello 用nix-store -q --references /nix/store/x3skf9wy7hpigvp8dca7kg1xafwhy5gv-hello 得到运行时依赖 /nix/store/vq3sdi8l15rzfl5zvmwpafrzis4sm6xf-glibc-2.37-8 /nix/store/c50v7bf341jsza0n07784yvzp5fzjpn5-gcc-12.3.0-lib /nix/store/kmp7p16z94gx9nm80n03j8cp9rllmla2-glibc-2.37-8-dev /nix/store/nd4dhnbh1wagnxh2fzd3cqb8ifzl2r43-gcc-12.3.0 /nix/store/x3skf9wy7hpigvp8dca7kg1xafwhy5gv-hello 嗯..glibc，gcc.. !? gcc, 我编译好的hello程序为啥还依赖gcc啊？ strings result/bin/hello | grep gcc /nix/store/vq3sdi8l15rzfl5zvmwpafrzis4sm6xf-glibc-2.37-8/lib:/nix/store/c50v7bf341jsza0n07784yvzp5fzjpn5-gcc-12.3.0-lib/lib /nix/store/nd4dhnbh1wagnxh2fzd3cqb8ifzl2r43-gcc-12.3.0/lib/gcc/x86_64-unknown-linux-gnu/12.3.0/include 还真依赖gcc 第一个是ldrpath，是用来在运行时寻找库文件的地方(对nix来说这是必须的，因为它不存在全局，不硬编码的话程序不知道位置) 但是我们并不需要这个这个运行时库。可以通过patchelf来修改二进制来除去rpath。同时也需要用strip来去除调试表(这也使得其依赖gcc) 这些操作可以在generic-builder.sh中完成，加条fixupPhase(别忘了在hellov2.nix的buildInputs中加入findutils 和 patchelf作为构建依赖) # fixup find $out -type f -exec patchelf --shrink-rpath '{}' \\; -exec strip '{}' \\; 2\u003e/dev/null 通过nix build --file hellov2.nix --print-out-paths 得到out path: /nix/store/vsrbxvz5psf44gdj7bq3wh0mwzqpx34w-hello 再通过nix-store -q --references /nix/store/vsrbxvz5psf44gdj7bq3wh0mwzqpx34w-hello 得到此时的运行时依赖： /nix/store/vq3sdi8l15rzfl5zvmwpafrzis4sm6xf-glibc-2.37-8 /nix/store/vsrbxvz5psf44gdj7bq3wh0mwzqpx34w-hello 哈哈，gcc没有啦！ great :) package is self-contained 复制一个包的运行时闭包到另一系统上能够直接运行(因为该包不依赖复制到的系统上的gcc(通过ldd result/bin/hello能够清楚地看到这一点))， 其只依赖在构建时的特定位置和版本(/nix/store)中的gcc 总之，Nix打出的包是自包含的 题外话：NAR(Nix ARchive) 为什么不用已有的归档格式(tar等)？ 它们都具有不确定性(不排序，添加时间戳…) NAR符合Nix，是reproducible的 可以通过nix-store --dump nix-store --restore nix nar ... nix store dump-path来管理NAR ","date":"2023-11-14","objectID":"/nix-pills-note-5/:2:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-5/#automatic-runtime"},{"categories":null,"content":" 1 第6篇","date":"2023-11-14","objectID":"/nix-pills-note-6/:1:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-6/#第6篇"},{"categories":null,"content":" 2 developing(debug) with nix-shell 当我们运行nix-shell hellov2.nix时，与nix-build的区别是其只会进入bash环境，并把derivation 中的参数作为环境变量传进去，但不会将args作为参数运行 即nix-shell环境下只有变量，不自动运行generic-builder.sh脚本 (当然想要运行构建脚本我们可以手动source generic-builder.sh) 但是手动source有许多坏处： 脚本在当前目录运行，没在特殊的隔离的环境中，原shell的环境可能会影响构建(impure) tar包被解压到当前目录，污染用户环境 generic-builder.sh没有被复制到/nix/store/中 但是nix-shell可以方便分步手动构建，调试。前提是构建是分步的，而且nix-shell有构建所需的环境(make,gcc,等) 为了同时满足nix-build 和 nix-shell的需求(即nix-build时运行args中的构建脚本，nix-shell不运行args构建脚本，只传入环境变量，可以利用环境变量手动调用构建步骤) 那么可以把构建步骤写成各个独立的函数，写在一个setup.sh里，作为环境变量传进shell(setup = ./setup.sh)。然后作为args参数的generic-builder.sh可以source $setup， 再调用setup.sh中的构建函数进行构建 结构如下： setup.sh # 不应该在这set -e，在generic-builder.sh中做 # 毕竟手动调用buildPhase等步骤时可不想因为某些错误就直接退出bash了 # set -e unset PATH for p in $baseInputs $buildInputs; do export PATH=$p/bin${PATH:+:}$PATH done function unpackPhase() { tar -xf $src for d in *; do if [ -d \"$d\" ]; then cd \"$d\" break fi done } function configurePhase() { ./configure --prefix=$out } function buildPhase() { make } function installPhase() { make install } function fixupPhase() { find $out -type f -exec patchelf --shrink-rpath '{}' \\; -exec strip '{}' \\; 2\u003e/dev/null } # generic build phase calling convenience for generic-builder.sh function genericBuild() { unpackPhase configurePhase buildPhase installPhase fixupPhase } autotoolsv2.nix可以这么写 let defaultAttrs = { builder = \"${pkgs.bash}/bin/bash\"; args = [ ./generic-builder.sh ]; baseInputs = with pkgs; [ gnutar gzip gnumake gcc coreutils gawk gnused gnugrep binutils.bintools ]; buildInputs = [ ]; system = builtins.currentSystem; setup = ./setup.sh; }; in derivation (defaultAttrs // attrs) generic-builder.sh set -e source $setup genericBuild 这时候我们的hellov3.nix可以这么写 let pkgs = import \u003cnixpkgs\u003e { }; mkDerivation = import ./autotoolsv2.nix pkgs; in mkDerivation { name = \"hellov3\"; src = ./hello-2.12.1.tar.gz; buildInputs = with pkgs; [ findutils patchelf ]; } nix-shell hellov3.nix进shell后，既可以手动source $setup来获得构建环境 也可以nix build --file hellov3.nix来直接构建了 ","date":"2023-11-14","objectID":"/nix-pills-note-6/:2:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-6/#developingdebug-with-nix-shell"},{"categories":null,"content":" 1 第7篇","date":"2023-11-14","objectID":"/nix-pills-note-7/:1:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-7/#第7篇"},{"categories":null,"content":" 2 garbage collector Nix有着比dpkg，rpm等更细粒度，更精确的垃圾回收 gc root是/nix/store下的文件或目录 Nix用了类似编程语言自动GC的概念及技术，有总是需要保留的GC roots(/nix/var/nix/gcroots/及/nix/var/nix/profiles/及/run/booted-system… 目录中指向的/nix/store/中的文件或目录)，所有直接或间接引用GC root的文件或目录都是需要保留的。除此之外的所有其它/nix/store/中的内容都gc掉(gc指的总是/nix/store目录下内容的清理) 当有旧的profile引用该derivation时其也不会被gc(因为旧的profile也在gc root list里) Nix先将/nix/store/中不在gc root list中的文件/目录移到/nix/store/trash中，这个操作是原子性的。然后清空/nix/store/trash 使用nix-collect-garbage进行gc 使用nix-store -q --roots [$(which p/nix/store/mdi7lvrn2mx7rfzv3fdq3v5yw8swiks6-hello-2.12.1ackname)|store drv path|store out path]查询引用了该derivation的gc root 使用nix-store --gc --print-roots来查看所有的gc roots 用nix-build等构建的result/bin/...都被/nix/var/nix/gcroots/auto/里间接引用，所以不会被gc nix-collect-garbage -d用于删除除了当前profile的所有profile并gc ","date":"2023-11-14","objectID":"/nix-pills-note-7/:2:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-7/#garbage-collector"},{"categories":null,"content":" 1 第8篇","date":"2023-11-14","objectID":"/nix-pills-note-8/:1:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-8/#第8篇"},{"categories":null,"content":" 2 input design pattern 我们已经写了一个setup.sh来方便nix-shell处于一个和nix-build类似的隔离环境，并有分步构建，手动调试的能力，并且用其来构建了一个包(GNU hello)。但是当包多了起来，集中管理就变得重要。除此之外，我们写的包过于耦合，不便于用户定制化(比如用户可能想要一个包的不同版本，或者为某个包添加特性等)，应该添加某些“选项”来让用户输入，而函数的参数正是用来做这个的 以构建graphviz-2.49.3.tar.gz来说 如果需要让其支持png格式，那么需要额外的库: gd，并且需要用pkg-config来提供编译选项。为了让Nix能在隔离的环境中让pkg-config找到对应的.pc文件，需要在setup.sh中export环境变量PKG_CONFIG_PATH (注：我们把findutils 和 patchelf加到了autotoolsv2.nix的baseInputs中) setup.sh for p in $baseInputs $buildInputs; do # other code ... if [ -d $p/lib/pkgconfig ]; then # libname/lib/pkgconfig 是包含.pc文件的目录 export PKG_CONFIG_PATH=\"$p/lib/pkgconfig${PKG_CONFIG_PATH:+:}$PKG_CONFIG_PATH\" fi done 然后在graphviz.nix中添加gd的包就行 graphviz.nix { mkDerivation, lib, gdSupport ? true, gd, pkg-config }: mkDerivation { name = \"graphviz\"; src = ./graphviz-2.49.3.tar.gz; buildInputs = if gdSupport then [ pkg-config (lib.getLib gd) (lib.getDev gd) ] else []; } hellov4.nix { mkDerivation, }: mkDerivation { name = \"hellov3\"; src = ./hello-2.12.1.tar.gz; } 把两个包集合在default.nix里 default.nix let pkgs = import \u003cnixpkgs\u003e { }; mkDerivation = import ./autotoolsv2.nix pkgs; in with pkgs; { hello = import ./hellov4.nix { inherit mkDerivation findutils patchelf; }; graphviz = import ./graphviz.nix { inherit mkDerivation lib gd pkg-config; }; graphvizCore = import ./graphviz.nix { inherit mkDerivation lib gd pkg-config; gdSupport = false; }; } 当我们想要构建其中的graphviz包时，可以nix-build -A graphviz ","date":"2023-11-14","objectID":"/nix-pills-note-8/:2:0","series":["nix-pills-note"],"tags":null,"title":"","uri":"/nix-pills-note-8/#input-design-pattern"}]